<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Análisis de Sentimiento</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://d3js.org/d3-geo.v2.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            padding: 20px;
        }
        
        .dashboard-container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .control-group {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .control-group label {
            font-weight: 600;
            margin-right: 10px;
            color: #444;
        }
        
        select, button {
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #ddd;
            background: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:focus, button:hover {
            outline: none;
            border-color: #1a2a6c;
            box-shadow: 0 0 0 3px rgba(26, 42, 108, 0.1);
        }
        
        button {
            background: linear-gradient(to right, #1a2a6c, #b21f1f);
            color: white;
            border: none;
            font-weight: 600;
            padding: 10px 25px;
        }
        
        .visualizations {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(700px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }
        
        .chart-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s ease;
        }
        
        .chart-container:hover {
            transform: translateY(-5px);
        }
        
        .chart-title {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #1a2a6c;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .chart {
            height: 400px;
            position: relative;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 14px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border-radius: 3px;
        }
        
        .country-label {
            font-size: 12px;
            fill: #555;
            text-anchor: end;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #666;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .visualizations {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .control-group {
                width: 100%;
                max-width: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <header>
            <h1>Análisis de Sentimiento en Redes Sociales</h1>
            <p class="subtitle">Dashboard interactivo para visualizar la evolución del sentimiento expresado en Twitter por país y fecha</p>
        </header>
        
        <div class="controls">
            <div class="control-group">
                <label for="year-select">Año:</label>
                <select id="year-select">
                    <option value="2022">2022</option>
                    <option value="2021">2021</option>
                    <option value="2020">2020</option>
                    <option value="2019">2019</option>
                    <option value="2018">2018</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="metric-select">Métrica:</label>
                <select id="metric-select">
                    <option value="score">Score de Sentimiento</option>
                    <option value="count">Cantidad de Tweets</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="reset-btn">Reiniciar Vista</button>
            </div>
        </div>
        
        <div class="visualizations">
            <div class="chart-container">
                <h2 class="chart-title">Mapa de Calor Temporal</h2>
                <div id="heatmap" class="chart"></div>
                <div class="legend" id="heatmap-legend"></div>
            </div>
            
            <div class="chart-container">
                <h2 class="chart-title">Evolución Mensual por País</h2>
                <div id="line-chart" class="chart"></div>
                <div class="legend" id="line-legend"></div>
            </div>
            
            <div class="chart-container">
                <h2 class="chart-title">Distribución Global de Sentimiento</h2>
                <div id="world-map" class="chart"></div>
                <div class="legend" id="map-legend"></div>
            </div>
            
            <div class="chart-container">
                <h2 class="chart-title">Top Países por Sentimiento</h2>
                <div id="bar-chart" class="chart"></div>
            </div>
        </div>
        
        <footer>
            <p>Dashboard de Análisis de Sentimiento | Datos de redes sociales 2018-2023</p>
            <p>El score de sentimiento varía de 0 (negativo) a 1 (positivo)</p>
        </footer>
    </div>

    <script>
        // Elimina o comenta la variable sampleData y la llamada a initDashboard

        let currentData = [];

        function loadYearData(year) {
            const filename = `sentimientos_${year}.csv`;
            d3.csv(filename).then(data => {
                // Convierte los campos numéricos
                data.forEach(d => {
                    d.N = +d.N;
                    d.SCORE = +d.SCORE;
                });
                currentData = data;
                initDashboard(currentData);
            });
        }

        // Modifica initDashboard para recibir los datos
        function initDashboard(rawData) {
            const processedData = preprocessData(rawData);
            const countries = Object.keys(processedData);
            const months = Array.from(new Set(
                Object.values(processedData).flatMap(c => Object.keys(c.data))
            )).sort();

            renderHeatmap(processedData, countries, months);
            renderLineChart(processedData, countries[0], months);
            renderWorldMap(processedData);
            renderBarChart(processedData);

            // No necesitas volver a agregar los event listeners aquí
        }

        // Carga el año seleccionado al iniciar y cuando cambie el select
        window.addEventListener('DOMContentLoaded', () => {
            const yearSelect = document.getElementById('year-select');
            loadYearData(yearSelect.value);

            yearSelect.addEventListener('change', () => {
                loadYearData(yearSelect.value);
            });

            document.getElementById('metric-select').addEventListener('change', () => {
                initDashboard(currentData);
            });

            document.getElementById('reset-btn').addEventListener('click', () => {
                initDashboard(currentData);
            });
        });

        // Preprocesar los datos para el dashboard
        function preprocessData(data) {
            // Agrupar por país y mes
            const processedData = {};
            const monthNames = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", 
                              "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
            
            data.forEach(d => {
                const date = new Date(d.DATE);
                const month = date.getMonth();
                const year = date.getFullYear();
                const monthYear = `${year}-${month}`;
                const monthName = `${monthNames[month]} ${year}`;
                const country = d.NAME_0;
                
                if (!processedData[country]) {
                    processedData[country] = {
                        name: country,
                        data: {},
                        totalTweets: 0,
                        avgScore: 0
                    };
                }
                
                if (!processedData[country].data[monthYear]) {
                    processedData[country].data[monthYear] = {
                        month: month,
                        year: year,
                        monthName: monthName,
                        totalTweets: 0,
                        sumScore: 0,
                        count: 0,
                        avgScore: 0
                    };
                }
                
                const monthData = processedData[country].data[monthYear];
                monthData.totalTweets += d.N;
                monthData.sumScore += d.SCORE * d.N;
                monthData.count += 1;
                monthData.avgScore = monthData.sumScore / monthData.totalTweets;
                
                processedData[country].totalTweets += d.N;
                processedData[country].sumScore += d.SCORE * d.N;
            });
            
            // Calcular promedios generales por país
            Object.keys(processedData).forEach(country => {
                processedData[country].avgScore = 
                    processedData[country].sumScore / processedData[country].totalTweets;
            });
            
            return processedData;
        }

        // Inicializar el dashboard
        function initDashboard() {
            const processedData = preprocessData(sampleData);
            const countries = Object.keys(processedData);
            const months = Array.from(new Set(
                Object.values(processedData).flatMap(c => Object.keys(c.data))
            )).sort();
            
            renderHeatmap(processedData, countries, months);
            renderLineChart(processedData, countries[0], months);
            renderWorldMap(processedData);
            renderBarChart(processedData);
            
            // Event listeners
            document.getElementById('year-select').addEventListener('change', () => {
                // En implementación real, filtrar por año
                initDashboard();
            });
            
            document.getElementById('metric-select').addEventListener('change', () => {
                // En implementación real, cambiar métrica
                initDashboard();
            });
            
            document.getElementById('reset-btn').addEventListener('click', () => {
                initDashboard();
            });
        }

        // 1. Mapa de calor temporal
        function renderHeatmap(data, countries, months) {
            const container = d3.select("#heatmap");
            container.selectAll("*").remove();
            
            const width = 700;
            const height = 400;
            const margin = { top: 50, right: 100, bottom: 50, left: 120 };
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const cellWidth = 30;
            const cellHeight = 20;
            
            // Escalas
            const x = d3.scaleBand()
                .domain(months)
                .range([0, width - margin.left - margin.right]);
            
            const y = d3.scaleBand()
                .domain(countries)
                .range([0, height - margin.top - margin.bottom]);
            
            // Escala de colores
            const colorScale = d3.scaleSequential()
                .domain([0.4, 0.8])
                .interpolator(d3.interpolateRdYlGn);
            
            // Dibujar celdas
            countries.forEach(country => {
                months.forEach(month => {
                    if (data[country].data[month]) {
                        const value = data[country].data[month].avgScore;
                        
                        svg.append("rect")
                            .attr("x", x(month))
                            .attr("y", y(country))
                            .attr("width", x.bandwidth())
                            .attr("height", y.bandwidth())
                            .attr("fill", colorScale(value))
                            .attr("stroke", "#fff")
                            .attr("stroke-width", 0.5)
                            .attr("rx", 3)
                            .attr("ry", 3)
                            .on("mouseover", function(event, d) {
                                d3.select(this).attr("stroke-width", 2).attr("stroke", "#333");
                                showTooltip(event, `<strong>${country}</strong><br>${data[country].data[month].monthName}
                                <br>Score: ${value.toFixed(3)}<br>Tweets: ${data[country].data[month].totalTweets}`);
                            })
                            .on("mouseout", function() {
                                d3.select(this).attr("stroke-width", 0.5).attr("stroke", "#fff");
                                hideTooltip();
                            })
                            .on("click", () => {
                                renderLineChart(data, country, months);
                            });
                        
                        // Texto en celdas para valores importantes
                        if (value > 0.75 || value < 0.5) {
                            svg.append("text")
                                .attr("x", x(month) + x.bandwidth()/2)
                                .attr("y", y(country) + y.bandwidth()/2)
                                .attr("text-anchor", "middle")
                                .attr("dy", "0.35em")
                                .attr("font-size", "10px")
                                .attr("fill", value > 0.7 ? "#fff" : "#333")
                                .text(value.toFixed(2));
                        }
                    }
                });
            });
            
            // Eje X
            svg.append("g")
                .attr("transform", `translate(0,${height - margin.top - margin.bottom})`)
                .call(d3.axisBottom(x).tickValues(months.filter((d, i) => i % 2 === 0)))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .attr("text-anchor", "end")
                .attr("dx", "-0.8em")
                .attr("dy", "0.15em");
            
            // Eje Y
            svg.append("g")
                .call(d3.axisLeft(y).tickSize(0))
                .selectAll("text")
                .attr("class", "country-label");
            
            // Título
            svg.append("text")
                .attr("x", (width - margin.left - margin.right) / 2)
                .attr("y", -20)
                .attr("text-anchor", "middle")
                .attr("font-size", "16px")
                .attr("font-weight", "bold")
                .text("Sentimiento Promedio por País y Mes");
            
            // Leyenda
            renderLegend("#heatmap-legend", colorScale, "Sentimiento (0-1)");
        }

        // 2. Gráfico de líneas para evolución temporal
        function renderLineChart(data, selectedCountry, months) {
            const container = d3.select("#line-chart");
            container.selectAll("*").remove();
            
            const width = 700;
            const height = 400;
            const margin = { top: 50, right: 100, bottom: 50, left: 60 };
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Obtener datos para el país seleccionado
            const countryData = data[selectedCountry];
            const lineData = Object.values(countryData.data).sort((a, b) => {
                return a.year === b.year ? a.month - b.month : a.year - b.year;
            });
            
            // Escalas
            const x = d3.scalePoint()
                .domain(lineData.map(d => d.monthName))
                .range([0, chartWidth]);
            
            const y = d3.scaleLinear()
                .domain([0.4, 0.9])
                .range([chartHeight, 0]);
            
            // Línea
            const line = d3.line()
                .x(d => x(d.monthName))
                .y(d => y(d.avgScore));
            
            // Dibujar línea
            svg.append("path")
                .datum(lineData)
                .attr("fill", "none")
                .attr("stroke", "#1a2a6c")
                .attr("stroke-width", 3)
                .attr("d", line);
            
            // Puntos de datos
            svg.selectAll(".dot")
                .data(lineData)
                .enter().append("circle")
                .attr("class", "dot")
                .attr("cx", d => x(d.monthName))
                .attr("cy", d => y(d.avgScore))
                .attr("r", 5)
                .attr("fill", "#b21f1f")
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("r", 8);
                    showTooltip(event, `<strong>${selectedCountry}</strong><br>${d.monthName}
                    <br>Score: ${d.avgScore.toFixed(3)}<br>Tweets: ${d.totalTweets}`);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("r", 5);
                    hideTooltip();
                });
            
            // Eje X
            svg.append("g")
                .attr("transform", `translate(0,${chartHeight})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .attr("text-anchor", "end")
                .attr("dx", "-0.8em")
                .attr("dy", "0.15em");
            
            // Eje Y
            svg.append("g")
                .call(d3.axisLeft(y).ticks(5));
            
            // Título
            svg.append("text")
                .attr("x", chartWidth / 2)
                .attr("y", -20)
                .attr("text-anchor", "middle")
                .attr("font-size", "16px")
                .attr("font-weight", "bold")
                .text(`Evolución del Sentimiento en ${selectedCountry}`);
            
            // Etiqueta eje Y
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (chartHeight / 2))
                .attr("dy", "1em")
                .attr("text-anchor", "middle")
                .text("Score de Sentimiento");
        }

        // 3. Mapa mundial de sentimiento
        function renderWorldMap(data) {
            const container = d3.select("#world-map");
            container.selectAll("*").remove();
            
            const width = 700;
            const height = 400;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Escala de colores
            const colorScale = d3.scaleSequential()
                .domain([0.4, 0.8])
                .interpolator(d3.interpolateRdYlGn);
            
            // Proyección
            const projection = d3.geoMercator()
                .scale(120)
                .translate([width / 2, height / 1.5]);
            
            // Crear un grupo para el mapa
            const g = svg.append("g");
            
            // Cargar datos del mundo (en un caso real sería desde un archivo)
            // Aquí creamos un mapa simple con los países de nuestros datos
            
            // Crear datos geoJSON simulados
            const geoData = {
                type: "FeatureCollection",
                features: Object.keys(data).map(country => ({
                    type: "Feature",
                    properties: {
                        name: country,
                        value: data[country].avgScore
                    },
                    geometry: {
                        type: "Point",
                        coordinates: [getRandomLon(), getRandomLat()]
                    }
                }))
            };
            
            // Dibujar países como círculos
            g.selectAll("circle")
                .data(geoData.features)
                .enter()
                .append("circle")
                .attr("cx", d => projection(d.geometry.coordinates)[0])
                .attr("cy", d => projection(d.geometry.coordinates)[1])
                .attr("r", d => Math.sqrt(data[d.properties.name].totalTweets) / 100)
                .attr("fill", d => colorScale(d.properties.value))
                .attr("stroke", "#fff")
                .attr("stroke-width", 0.5)
                .attr("opacity", 0.8)
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("stroke-width", 2).attr("stroke", "#333");
                    showTooltip(event, `<strong>${d.properties.name}</strong><br>
                        Score: ${d.properties.value.toFixed(3)}<br>
                        Tweets: ${data[d.properties.name].totalTweets}`);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("stroke-width", 0.5).attr("stroke", "#fff");
                    hideTooltip();
                })
                .on("click", d => {
                    renderLineChart(data, d.properties.name, Object.keys(data[d.properties.name].data));
                });
            
            // Etiquetas para países importantes
            const importantCountries = ["United States", "Brazil", "India", "China", "United Kingdom"];
            geoData.features.filter(d => importantCountries.includes(d.properties.name))
                .forEach(d => {
                    g.append("text")
                        .attr("x", projection(d.geometry.coordinates)[0])
                        .attr("y", projection(d.geometry.coordinates)[1] - Math.sqrt(data[d.properties.name].totalTweets)/100 - 5)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "10px")
                        .attr("fill", "#333")
                        .text(d.properties.name);
                });
            
            // Título
            svg.append("text")
                .attr("x", width / 2)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .attr("font-size", "16px")
                .attr("font-weight", "bold")
                .text("Distribución Global del Sentimiento");
            
            // Leyenda
            renderLegend("#map-legend", colorScale, "Sentimiento (0-1)");
        }

        // 4. Gráfico de barras para top países
        function renderBarChart(data) {
            const container = d3.select("#bar-chart");
            container.selectAll("*").remove();
            
            const width = 700;
            const height = 400;
            const margin = { top: 50, right: 30, bottom: 70, left: 80 };
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Preparar datos (top 10 países por score)
            const topCountries = Object.values(data)
                .sort((a, b) => b.avgScore - a.avgScore)
                .slice(0, 10);
            
            // Escalas
            const x = d3.scaleBand()
                .domain(topCountries.map(d => d.name))
                .range([0, chartWidth])
                .padding(0.2);
            
            const y = d3.scaleLinear()
                .domain([0.5, 0.8])
                .range([chartHeight, 0]);
            
            // Escala de colores
            const colorScale = d3.scaleSequential()
                .domain([0.5, 0.8])
                .interpolator(d3.interpolateRdYlGn);
            
            // Barras
            svg.selectAll(".bar")
                .data(topCountries)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.name))
                .attr("y", d => y(d.avgScore))
                .attr("width", x.bandwidth())
                .attr("height", d => chartHeight - y(d.avgScore))
                .attr("fill", d => colorScale(d.avgScore))
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("opacity", 0.8);
                    showTooltip(event, `<strong>${d.name}</strong><br>
                        Score: ${d.avgScore.toFixed(3)}<br>
                        Tweets: ${d.totalTweets}`);
                })
                .on("mouseout", function() {
                    d3.select(this).attr("opacity", 1);
                    hideTooltip();
                })
                .on("click", d => {
                    const months = Object.keys(d.data);
                    renderLineChart(data, d.name, months);
                });
            
            // Etiquetas de valor
            svg.selectAll(".label")
                .data(topCountries)
                .enter().append("text")
                .attr("class", "label")
                .attr("x", d => x(d.name) + x.bandwidth() / 2)
                .attr("y", d => y(d.avgScore) - 5)
                .attr("text-anchor", "middle")
                .attr("font-size", "12px")
                .text(d => d.avgScore.toFixed(3));
            
            // Eje X
            svg.append("g")
                .attr("transform", `translate(0,${chartHeight})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .attr("text-anchor", "end")
                .attr("dx", "-0.8em")
                .attr("dy", "0.15em");
            
            // Eje Y
            svg.append("g")
                .call(d3.axisLeft(y).ticks(5));
            
            // Título
            svg.append("text")
                .attr("x", chartWidth / 2)
                .attr("y", -20)
                .attr("text-anchor", "middle")
                .attr("font-size", "16px")
                .attr("font-weight", "bold")
                .text("Top 10 Países por Sentimiento Positivo");
            
            // Etiqueta eje Y
            svg.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left)
                .attr("x", 0 - (chartHeight / 2))
                .attr("dy", "1em")
                .attr("text-anchor", "middle")
                .text("Score de Sentimiento");
        }

        // Función auxiliar para mostrar tooltips
        function showTooltip(event, content) {
            const tooltip = d3.select("body")
                .append("div")
                .attr("class", "tooltip")
                .html(content);
            
            tooltip
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px")
                .transition()
                .duration(200)
                .style("opacity", 1);
        }

        function hideTooltip() {
            d3.select(".tooltip").remove();
        }

        // Función para renderizar leyenda
        function renderLegend(selector, colorScale, title) {
            const legend = d3.select(selector);
            legend.html("");
            
            const gradientSteps = 10;
            const legendWidth = 300;
            const legendHeight = 20;
            
            const svg = legend.append("svg")
                .attr("width", legendWidth)
                .attr("height", 50);
            
            // Crear gradiente
            const defs = svg.append("defs");
            const gradient = defs.append("linearGradient")
                .attr("id", "legend-gradient")
                .attr("x1", "0%")
                .attr("x2", "100%")
                .attr("y1", "0%")
                .attr("y2", "0%");
            
            for (let i = 0; i <= gradientSteps; i++) {
                const value = i / gradientSteps;
                gradient.append("stop")
                    .attr("offset", `${value * 100}%`)
                    .attr("stop-color", colorScale(value * 0.4 + 0.4));
            }
            
            // Dibujar rectángulo con gradiente
            svg.append("rect")
                .attr("x", 0)
                .attr("y", 10)
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .style("fill", "url(#legend-gradient)")
                .attr("rx", 3)
                .attr("ry", 3);
            
            // Añadir etiquetas
            svg.append("text")
                .attr("x", 0)
                .attr("y", 5)
                .text("0.4 (Negativo)")
                .attr("font-size", "12px");
            
            svg.append("text")
                .attr("x", legendWidth)
                .attr("y", 5)
                .attr("text-anchor", "end")
                .text("0.8 (Positivo)")
                .attr("font-size", "12px");
            
            svg.append("text")
                .attr("x", legendWidth / 2)
                .attr("y", 5)
                .attr("text-anchor", "middle")
                .text(title)
                .attr("font-size", "12px")
                .attr("font-weight", "bold");
        }

        // Funciones auxiliares para generar coordenadas aleatorias
        function getRandomLat() {
            return Math.random() * 160 - 80; // Entre -80 y 80
        }
        
        function getRandomLon() {
            return Math.random() * 360 - 180; // Entre -180 y 180
        }

        // Inicializar el dashboard cuando se carga la página
        window.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html>